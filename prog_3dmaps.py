# -*- coding: utf-8 -*-
"""Prog_3dMaps.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1S4XZICRCcSbFnVYrRczYUj9HRK9sfS4C
"""

import os
import json
import numpy as np

# Percorsi
os.makedirs('/content/data/images', exist_ok=True)
os.makedirs('/content/data/detect', exist_ok=True)
os.makedirs('/content/data/depth', exist_ok=True)
os.makedirs('/content/results/mapped_points', exist_ok=True)
print("Struttura delle directory completata!")

from google.colab import drive
drive.mount('/content/drive')

# Copia il dataset da Drive alla directory di lavoro
!cp -r /content/drive/MyDrive/_StreetLampMappingPJ/datasets/* /content/data/images/
!cp -r /content/drive/MyDrive/_StreetLampMappingPJ/detectedImage/* /content/data/detect
!cp -r /content/drive/MyDrive/_StreetLampMappingPJ/depthImage/* /content/data/depth

# Carica i dati delle bounding box
with open('/content/data/detect/detection_results.json', "r") as f:
    detections = json.load(f)

# Funzione per calcolare le coordinate 3D
def calculate_3d_coordinates(bbox, depth_map):
    x, y, w, h = bbox["x_min"], bbox["y_min"], bbox["width"], bbox["height"]
    if int(y + h) > depth_map.shape[0] or int(x + w) > depth_map.shape[1]:
        return None
    depth = depth_map[int(y):int(y + h), int(x):int(x + w)].mean()
    return [x + w / 2, y + h / 2, depth]

from PIL import Image
# Salva le coordinate 3D
depth_dir = "/content/data/depth"
res_dir = "/content/results/mapped_points"

lst = os.listdir(depth_dir)
for i in range(len(lst)):
    img_file = f'img{i + 1}.png'
    depth_map = np.array(Image.open(os.path.join(depth_dir, img_file)))
    points_3d = [
        calculate_3d_coordinates(bbox, depth_map)
        for bbox in detections if bbox["image"] == img_file
    ]
    points_3d = [p for p in points_3d if p is not None]
    if points_3d:
      np.save(os.path.join(res_dir, f"{img_file.split('.')[0]}.npy"), points_3d)
    print(f"[{i+1}/{len(lst)}]Saved 3D points for {img_file}, results saved in {res_dir}")

# Offset per simulare la progressione temporale
time_offset = 5

for i, file in enumerate(sorted(os.listdir(res_dir))):
    points = np.load(os.path.join(res_dir, file))
    if points.ndim == 2 and points.shape[1] == 3:
        points[:, 0] += i * time_offset
        np.save(os.path.join(res_dir, file), points)

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Creazione del grafico 3D
fig = plt.figure(figsize=(10, 10))
ax = fig.add_subplot(111, projection='3d')

# Carica e plotta i punti
for file in sorted(os.listdir(res_dir)):
    points = np.load(os.path.join(res_dir, file))
    if points.ndim != 2 or points.shape[1] != 3:
        continue
    ax.scatter(points[:, 0], points[:, 1], points[:, 2], label=file)

ax.set_xlabel("X (pixel)")
ax.set_ylabel("Y (pixel)")
ax.set_zlabel("Z (profondità)")
ax.set_title("Visualizzazione 3D dei Lampioni")
#plt.legend()
plt.show()

# Esempio di caricamento di un file di punti 3D
import numpy as np
points_3d = np.load('/content/results/mapped_points/img1.npy')

# Statistiche
depths = points_3d[:, 2]
print(f"Numero di lampioni: {len(depths)}")
print(f"Profondità media: {np.mean(depths):.2f}")
print(f"Deviazione standard: {np.std(depths):.2f}")